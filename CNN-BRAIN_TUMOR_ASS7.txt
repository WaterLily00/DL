7 Build Brain tumor classification model with CNN .,

code :-


# 1️ IMPORT LIBRARIES .,

import zipfile                     # To extract compressed ZIP dataset files
import os                          # For handling file paths and directory operations
import random                      # For selecting random images for predictions
import numpy as np                 # For numerical operations and array manipulations
import matplotlib.pyplot as plt    # For plotting graphs and showing sample images

# TensorFlow and Keras modules for deep learning
      
import tensorflow as tf  
from tensorflow.keras.preprocessing.image import ImageDataGenerator, image          # Loads & augments images
from tensorflow.keras.models import Sequential                                      # Builds the CNN model layer by layer
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout   # CNN and Dense layers


# 2️ UNZIP THE DATASET .,

# Unzips the dataset into a specified folder
zip_path = "/home/student/Downloads/brain tumour.zip"
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall("/home/student/Downloads/brain_tumour")


# 3️ DEFINE DATASET PATHS .,

train_dataset_path = '/home/student/Downloads/brain_tumour/Training'
test_dataset_path  = '/home/student/Downloads/brain_tumour/Testing'


# 4️ DEFINE BASIC PARAMETERS .,

input_shape = (224, 224, 3)  # image size and color channels
batch_size = 32              # images processed per step
epochs = 10                  # number of training cycles


# 5️ CREATE DATA GENERATORS .,

# ImageDataGenerator automatically loads images, rescales pixel values, 
# and groups them by folder names (class labels).

train_datagen = ImageDataGenerator(rescale=1./255)

# Training data generator

train_generator = train_datagen.flow_from_directory(
    train_dataset_path,
    target_size=(input_shape[0], input_shape[1]),  # resize images
    batch_size=batch_size,
    class_mode='categorical'                      # since we have multiple tumor types
)

# Test data generator

test_generator = train_datagen.flow_from_directory(
    test_dataset_path,
    target_size=(input_shape[0], input_shape[1]),
    batch_size=batch_size,
    class_mode='categorical'
)


# 6️ BUILD CNN MODEL .,

# CNN learns visual patterns like edges and textures from MRI images.

model = Sequential()

# First Convolutional + Pooling layer

model.add(Conv2D(64, kernel_size=3, activation='relu', input_shape=input_shape))
model.add(MaxPooling2D(2, 2))

# Second Convolutional + Pooling layer

model.add(Conv2D(32, kernel_size=3, activation='relu'))
model.add(MaxPooling2D(2, 2))

# Third Convolutional + Pooling layer

model.add(Conv2D(16, kernel_size=3, activation='relu'))
model.add(MaxPooling2D(2, 2))

# Flatten converts 3D feature maps → 1D vector

model.add(Flatten())

# Fully connected (Dense) layers to combine features

model.add(Dense(128, activation='relu'))
model.add(Dense(256, activation='relu'))
model.add(Dense(384, activation='relu'))
model.add(Dense(256, activation='relu'))

# Output layer — 4 neurons for 4 classes (Softmax → probabilities)

model.add(Dense(4, activation='softmax'))


# 7️ COMPILE MODEL .,

# - Optimizer: 'adam' adjusts learning rate automatically
# - Loss: 'categorical_crossentropy' for multi-class tasks
# - Metrics: 'accuracy' tracks how well the model performs

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# 8️ TRAIN THE MODEL .,

# model.fit() runs the training process
# Each epoch → one complete pass through training data

H = model.fit(train_generator, epochs=4, validation_data=test_generator)


# 9️ DISPLAY CLASS LABELS .,

# Lists all tumor class names from the training folder

labels = os.listdir(train_dataset_path)
print("Class Labels:", labels)

# 10 RANDOM IMAGE TESTING FUNCTION .,

# This function picks a random image from any subfolder for testing

def get_random_paths(path):
    imgs = []
    for root, dirs, files in os.walk(path):
        for file in files:
            if file.endswith('.jpg'):
                imgs.append(os.path.join(root, file))
    return random.choice(imgs)

# Example: get a random test image
x_test_path = get_random_paths(test_dataset_path)

# 1️1️ SINGLE IMAGE PREDICTION .,

# Loads one random test image and predicts its class

img = image.load_img(x_test_path, target_size=(input_shape[0], input_shape[1]))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, 0)  # add batch dimension


# 1️2️ VISUALIZE PREDICTIONS FOR EACH CLASS .,

# Displays one random image from each tumor category

plt.figure(figsize=(15, 5))

for i, class_name in enumerate(labels):
    class_path = os.path.join(test_dataset_path, class_name)
    imgs = [f for f in os.listdir(class_path) if f.endswith('.jpg')]
    if not imgs:
        continue

    img_file = np.random.choice(imgs)
    img_path = os.path.join(class_path, img_file)

    # Preprocess image before prediction
    img = image.load_img(img_path, target_size=(input_shape[0], input_shape[1]))
    img_array = image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    # Predict and find the most probable class
    predicted_values = model.predict(img_array)
    predicted_index = np.argmax(predicted_values)
    predicted_class = labels[predicted_index]

    plt.subplot(1, len(labels), i+1)
    plt.imshow(img)
    plt.title(predicted_class)
    plt.axis('off')

plt.show()


# 1️3️ PLOT TRAINING PERFORMANCE .,

# Plot loss and accuracy curves to visualize training progress

plt.plot(H.history['loss'], label='Training Loss')
plt.plot(H.history['accuracy'], label='Training Accuracy')
plt.title("Training Performance")
plt.xlabel("Epochs")
plt.ylabel("Value")
plt.legend()
plt.show()


# 1️4 FINAL MODEL EVALUATION .,

# Evaluate the trained CNN on test data
# Returns test loss and accuracy

test_loss, test_acc = model.evaluate(test_generator)
print(f"\n Test Accuracy: {test_acc*100:.2f}%")

# THEORY :- 

# CNN Architecture:
 Input → Conv2D → ReLU → Pooling → Conv2D → ReLU → Pooling →
 Conv2D → Pooling → Flatten → Dense → Softmax

# Key Concepts:
 - Convolution extracts spatial features.
 - MaxPooling reduces feature map size and computation.
 - ReLU introduces non-linearity.
 - Flatten converts 2D to 1D vector for Dense layers.
 - Dense layers learn decision boundaries.
 - Softmax gives probability distribution over 4 classes.

# Important Formulas:
 1. Convolution: Z(i,j) = Σ_m Σ_n (Input(i+m,j+n) × Kernel(m,n)) + b
 2. ReLU: f(z) = max(0, z)
 3. Softmax: σ(z_i) = e^(z_i) / Σ_j e^(z_j)
 4. Loss: L = -Σ(y_true * log(y_pred))

# Model Summary:
 This CNN learns to classify brain MRI images into 4 tumor categories
 (e.g., glioma, meningioma, pituitary, or no tumor) by extracting 
 key visual features from training data.
